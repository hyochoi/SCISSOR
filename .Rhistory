# robust projection scores by projecting X onto dir.
require(MASS)
return(apply(X,2,FUN=function(t){rlm(t ~ dir - 1, psi=psi.bisquare)$coefficients}))
}
maincomp = function(x) {
# 1 = main / 0 = outlier
require(diptest)
if (dip.test(x)$p.value<0.005) {
(max(abs(correct_PO(pd.rate.hy(x,qrsc=T))))<3)
} else {
(max(abs(correct_PO(pd.rate.hy(x,qrsc=T))))<4)
}
}
z.pca = pca.hy(normData,subt.mean=F)
pc.j = which(apply(z.pca$projmat[1:5,],1,maincomp)==1)
if (length(pc.j)>0) {
rprojmat = apply(matrix(z.pca$dirmat[,pc.j],ncol=length(pc.j)),2,
FUN=function(t){get_rps(X=normData,dir=t)})
normData2 = normData - z.pca$dirmat[,pc.j]%*%t(rprojmat)
} else {
normData2 = normData
}
start.time=Sys.time()
set.seed(0)
globalResult = miscGlobal_test5(siglev=siglev,ADcutoff=4,
inputData=normData2,pileupData=pileupData,
Ranges=Ranges,JSR.table=JSR.table,print.proc=F)
localResult = miscLocal_test2(siglev=siglev,windowSize=50,
miscGlobalResult=globalResult,
inputData=normData2,pileupData=pileupData,
Ranges=Ranges,JSR.table=JSR.table)
end.time=Sys.time()
end.time-start.time
globalResult$table
localResult$table
# kdeplot.hy(globalResult$OS,indlist=globalResult$Outlier,text=T)
dim(globalResult$table)
dim(localResult$table)
kdeplot.hy(globalResult$OS)
par(mfrow=c(4,4))
kdeplot.hy(globalResult$OS)
kdeplot.hy(localResult$OS)
localResult$cutoff
abline(v=localResult$cutoff)
kdeplot.hy(globalResult$OS)
abline(v=globalResult$cutoff)
Gene
GeneName
# rm(list=ls())
today=Sys.Date()
sysinfo=Sys.info()
if (sysinfo["sysname"]=="Darwin") {
user="~/"
hayeslab="/Volumes/hayeslab/"
tumor.dir=paste0(user,"Dropbox/Research/Hayes-lab/HNSC_local/")
base=paste0(tumor.dir,"hnsc_basis/")
pileup.dir=paste0(user,"Dropbox/Research/Data/HNSC_EE_coverage/");
} else if (sysinfo["sysname"]=="Linux") {
user="/datastore/primary/UTHSC/Current_members/Hyoyoung_Choi/"
hayeslab="/datastore/primary/UTHSC/"
hyoyoung=paste0(hayeslab,"Current_members/Hyoyoung_Choi/")
# Rsource=paste0(hyoyoung,"Rsource/")
tumor.dir=paste0(hyoyoung,"HNSC/")
base=paste0(tumor.dir,"base/")
pileup.dir=paste0(tumor.dir,"pileup/")
} else if (sysinfo["sysname"]=="Windows") {
user=paste0("C:/Users/",sysinfo["login"],"/")
hayeslab="Z:/"
}
# devtools::install_github("hyochoi/SCISSOR")
# devtools::install_github("hyochoi/RPlotRNAseq")
# devtools::install_github("hyochoi/OutSiDer")
library(SCISSOR)
library(OutSiDer)
library(RPlotRNAseq)
library(RColorBrewer)
library(dplyr)
plot_pileup2 = function(Pileup,Ranges,cases=NULL,gene.mutation=NULL,
logcount=NULL,
plot.meanpileup=TRUE,
col.pileup=NULL,col.meanpileup="grey",
main=NULL,cex.main=1.2,
print.ranges=TRUE,
xlim=NULL,ylim=NULL,xlab=NULL,ylab=NULL,...) {
##  % needed variables
if (missing(Pileup)) {
stop("Pileup is missing")
}
if (missing(Ranges)) {
stop("Genomic ranges should be needed (See get_Ranges)")
}
samplist = colnames(Pileup)
n = ncol(Pileup)
exons = Ranges$lRanges[,c(2,3)]
if (is.null(cases)) cases = 1:n
if (!is.numeric(cases)) {
caseIDs=cases
cases=which(samplist %in% caseIDs)
if (length(cases)==0) {
stop("No sample matches with the given case IDs.")
}
}
require("RColorBrewer")
candicol1 = c(brewer.pal(9,"Pastel1")[6], # candidate colors for exonic regions
brewer.pal(8,"Pastel2")[6],
brewer.pal(9,"YlOrBr")[1],
brewer.pal(9,"YlOrRd")[1],
brewer.pal(9,"YlOrRd")[2],
brewer.pal(9,"Reds")[1],
brewer.pal(9,"RdPu")[1],
brewer.pal(9,"OrRd")[1],
brewer.pal(9,"OrRd")[2],
brewer.pal(9,"Oranges")[1],
brewer.pal(9,"Oranges")[2],
"aliceblue");
candicol2 = brewer.pal(12,"Set3") # candidiate colors for regions with shape changes
candicol3 = brewer.pal(8,"Pastel2") # candidiate colors for regions with shape changes
candicol = c(candicol2,candicol3);
exon.col = candicol1[9]
# Set plot parameters
if (is.null(xlim)) xlim = c(0,nrow(Pileup))
if (is.null(ylim)) ylim = c(yaxis.hy(Pileup))
ylim = 1.1*ylim
const = 0.06*(ylim[2]-min(0,ylim[1]))
if (is.null(xlab)) xlab = "Genomic positions"
if (is.null(ylab)) ylab = "Read depth"
if (is.null(main)) {
if (length(cases)>1) {
main = paste0(Ranges$Gene)
} else if (length(cases)==1) {
main = paste0(Ranges$Gene," | sample #",cases," (ID:",samplist[cases],")")
}
}
# pileup colors
if (is.null(col.pileup)) {
if (length(cases)>10) {
x.mda = svd(Pileup) ;
projmat = diag(x.mda$d)%*%t(x.mda$v) ;
projmat[1,] = -projmat[1,] ;
# colset = rainbow(n=length(projmat[1,]), start=0, end=0.756)[rank(-projmat[1,])]
colset = colorRampPalette(brewer.pal(10, "Spectral"))(n)[rank(-projmat[1,])]
} else {
colset = rep("black",n)
}
} else {
if (length(col.pileup)==n) {
colset=col.pileup
} else {
colset = rep("black",n)
colset[cases] = rep(col.pileup,length=length(cases))
}
}
# Start plotting
if (print.ranges) {
par(mar=c(3.2,4,3,2))
} else {
par(mar=c(3,4,3,2))
}
meanPileup = apply(Pileup, 1, median) ;
plot(meanPileup+const, type='l', lty=2, lwd=0.5, ylim=c(min(0,ylim[1]),ylim[2]),
xlim=xlim, axes=F, ylab=NA, xlab=NA, xaxs="i",yaxs="i", col="white") ;
for (i in 1:nrow(exons)){
polygon(x=c(rep(exons[i,1],2),rep(exons[i,2],2)),y=c(const,(max(Pileup)+10000),(max(Pileup)+10000),const),col=exon.col,border=NA) ;
}
# abline(v=exons[,1],lty=1,col="lightyellow3",lwd=0.1) ;
# abline(v=exons[,2],lty=1,col="lightyellow3",lwd=0.1) ;
title(main, cex.main=cex.main,font.main=1,line=0.5);
if (print.ranges) {
x.tick.at = c(1,Ranges$lRanges[2:nrow(Ranges$lRanges),2],max(Ranges$lRanges))
x.labels.l = c(Ranges$Gene,Ranges$lRanges[2:nrow(Ranges$lRanges),2],max(Ranges$lRanges))
x.labels.c = c(Ranges$Gene,Ranges$cRanges[2:nrow(Ranges$lRanges),1],max(Ranges$cRanges))
x.labels.g = c(Ranges$chr,Ranges$gRanges[2:nrow(Ranges$gRanges),2],max(Ranges$gRanges))
exon.tick.at = c(1,apply(Ranges$lRanges[,c(2,3)],1,mean))
exon.labels = c(Ranges$Gene,paste("E",1:dim(Ranges$lRanges)[1],sep=""))
axis(side=1, tck=-0.01, at=x.tick.at, labels=NA, col.ticks="darkgrey")
# axis(side=1, lwd=0, line=-1, cex.axis=0.8,col.axis="darkgrey",
#      at=x.tick.at,labels=x.labels.c) ;
axis(side=1, lwd=0, line=-1, cex.axis=0.8,col.axis="darkgrey",
at=exon.tick.at,labels=exon.labels) ;
axis(side=1, lwd=0, line=-0.1, cex.axis=0.8,col.axis="darkgrey",
at=x.tick.at,labels=x.labels.g)
mtext(side=1, xlab, line=2, cex=1)
} else {
mtext(side=1, xlab, line=1, cex=1)
}
if (!is.null(logcount)) {
if (logcount==1) {
labels = c(0,1,5,10,50,100,300,500,1000,2000,5000,10000,15000,20000,30000)
} else {
labels = c(0,5,10,50,100,300,500,1000,2000,5000,10000,15000,20000,30000)
}
tick.at = log10(labels+logcount)-log10(logcount)+const;
} else {
tick.at = NULL;
labels = TRUE;
}
axis(side=2, tck=-0.02, at=tick.at, col.ticks="darkgrey",las=1,
labels=labels,lwd=0,line=-0.8,cex.axis=0.8,col.axis="darkgrey")
mtext(side=2, ylab, line=2, cex=1) ;
axis(side=2, tck=-0.02, at=(ylim[1]+0.5*(const-ylim[1])), col.ticks="darkgrey",las=1,
labels="Mutation",lwd=0,line=-0.8,cex.axis=0.8,col.axis="black")
if (plot.meanpileup){
points(meanPileup+const, type='l', lty=1, lwd=2, col=col.meanpileup) ;
}
gaxis = c()
for (g in 1:nrow(Ranges$gRanges)) {
gaxis = c(gaxis,Ranges$gRanges[g,1]:Ranges$gRanges[g,4])
}
for (case in cases) {
points(Pileup[,case]+const, type='l', lty=1, col=colset[case], ...) ;
if (!is.null(gene.mutation)) {
# mutations
mutation_rows = which(gene.mutation$caseIDs==samplist[case])
if (length(mutation_rows)==0) {
text(x=(0.5*(xlim[2]-xlim[1])),y=(ylim[1]+0.5*(const-ylim[1])),
labels="No mutation",cex=0.8)
} else {
for (i in mutation_rows) {
segments(x0=which(gaxis==gene.mutation[i,1]),x1=which(gaxis==gene.mutation[i,1]),
y0=ylim[1],y1=const,col="red",lwd=2)
}
}
}
}
# box(lwd=2)
segments(x0=xlim[1],y0=const,y1=ylim[2],lwd=4)
segments(x0=xlim[2],y0=const,y1=ylim[2],lwd=4)
segments(x0=xlim[1],y0=const,x1=xlim[2],lwd=2)
segments(x0=xlim[1],y0=ylim[2],x1=xlim[2],lwd=4)
segments(x0=xlim[1],y0=min(0,ylim[1]),x1=xlim[2],lwd=2)
# abline(v=c(xlim[1],xlim[2]),lwd=2)
# abline(h=c(const,ylim[2]),lwd=3)
}
yaxis.hy <- function(mat){
#  mat : d by n matrix
tempmax <- max(mat) ;
tempmin <- min(mat) ;
templen <- tempmax-tempmin ;
return(c(tempmin-0.002*templen, tempmax+0.002*templen)) ;
}
if (sysinfo["sysname"]=="Darwin") {
parent.dir = paste0(tumor.dir,"method_test/")
} else if (sysinfo["sysname"]=="Linux") {
parent.dir = paste0(tumor.dir,"analysis/SCISSOR_v8/method_test/")
}
setwd(parent.dir)
GenesExons=read.table(file=paste0(base,'out_exons_positions.txt'), header=FALSE, colClasses="character") ;
regular.gene=read.table(file=paste0(base,"GEr2_regular_genes.txt"),header=FALSE,colClasses="character")[,1]
genome.list=read.table(paste0(base,'genome_list_original.txt',sep=""), header=FALSE, colClasses="character")[,1] ;
manifest.tumor = read.table(paste0(base,"HNSC_RNA_manifest_datastore_tumor.txt"),
header=F,colClasses="character")
degraded.barcode = read.table(paste0(base,"HNSC_70_degraded_barcode.txt"),
header=F,colClasses="character")[,1]
## Get sample IDs of interest
sample.barcode = manifest.tumor[which(! manifest.tumor[,1] %in% degraded.barcode),1]
simple.barcode = substr(sample.barcode,6,12)
## Load mutation info.
load(file=paste0(base,"Mutations_info_452.RData"))  # from 481 (or 452) tumor samples:: Splice.mat, mutations_mat, tumor_barcode, Genome.list, mut_types, myGeneS.info, tumor_barcode2
method.dir = paste0("~/Dropbox/Research/Hayes-lab/HNSC_local/method_test/")
# data.dir = paste0("~/Desktop/HNSC/analysis/SCISSOR_v8/method_test/test_data/")
data.dir = paste0("~/Dropbox/Research/Hayes-lab/HNSC_local/method_test/tmp_data/")
SCISSORdir = paste0("~/Dropbox/Research/hyochoi_GitHub/SCISSOR/")
source(paste0(method.dir,"test.R"))
source(paste0(method.dir,"scratch.R"))
source(paste0(SCISSORdir,"R/get_junctions.R"))
source(paste0(SCISSORdir,"R/junction_outliers.R"))
GeneName="FAT1"
logshiftVal = 10
siglev = 1e-4
regions = GenesExons[which(GenesExons[,1]==GeneName),2]
if (GeneName=="TP53") {
regions = "chr17:7571720-7573008,7573927-7574033,7576525-7576657,7576853-7576926,7577019-7577155,7577499-7577608,7578177-7578289,7578371-7578554,7579312-7579590,7579700-7579721,7579839-7579940:-"
}
Ranges = get_Ranges(Gene=GeneName,regions=regions,outputType="part_intron")
load(file=paste0(data.dir,GeneName,"_pileup.RData"))
JSR.count = read.table(file=paste0(data.dir,GeneName,"_SRcount.txt"),header=T)
# source(paste0(SCISSORdir,"R/get_junctions.R"))
jsrCount = data.matrix(JSR.count[,2])
rownames(jsrCount) = JSR.count[,1]
# head(jsrCount)
junction.anno = get_junctions(jsrCount=jsrCount,Ranges=Ranges)
JSR.table = junction.anno$JSR.annotation
JSR.matrix = junction.anno$JSRmat
## Mutations
mutation.info = myGeneS.info[[which(genome.list==GeneName)]]
impt.mutations=c("Splice_Site","Nonsense_Mutation","In_Frame_Ins",
"Frame_Shift_Del","In_Frame_Del","Frame_Shift_Ins",
"Silent")
group_mut = as.list(NULL);
group_mut[[1]] = which(mut_types=="Splice_Site")
group_mut[[2]] = which(mut_types=="Nonsense_Mutation") # nonsense
group_mut[[3]] = c(which(mut_types=="In_Frame_Ins"),which(mut_types=="Frame_Shift_Del"),
which(mut_types=="In_Frame_Del"),which(mut_types=="Frame_Shift_Ins")) # frame shift
group_mut[[4]] = which(mut_types=="Silent") # silent
group_mut[[5]] = which(!mut_types %in% impt.mutations)  # the rest
group_mut_types = c("Splice_site","Nonsense","Frame_shift","Silent","Other")
GeneName
start.time=Sys.time()
set.seed(0)
if (exists(x="ScissorOutput")) rm(ScissorOutput)
ScissorOutput=Scissor(pileupData=pileupData,Ranges=Ranges,
siglev=siglev,logshiftVal=logshiftVal,windowSize=50,
plotNormalization=FALSE,reducedReturn=FALSE)
end.time=Sys.time()
end.time-start.time
data.process = process_pileup(pileupData=pileupData,Ranges=Ranges,
logshiftVal=logshiftVal,
plotNormalization=F)
if (exists(x="normData")) rm(normData)
if (exists(x="logData")) rm(logData)
normData = data.process$normalizedData
logData = data.process$logData
logshiftVal = data.process$logshiftVal  # log shift parameter
cat(paste0("     Log shift parameter used  = ",logshiftVal),"\n")
get_rps = function(X,dir) {
# robust projection scores by projecting X onto dir.
require(MASS)
return(apply(X,2,FUN=function(t){rlm(t ~ dir - 1, psi=psi.bisquare)$coefficients}))
}
maincomp = function(x) {
# 1 = main / 0 = outlier
require(diptest)
if (dip.test(x)$p.value<0.005) {
(max(abs(correct_PO(pd.rate.hy(x,qrsc=T))))<3)
} else {
(max(abs(correct_PO(pd.rate.hy(x,qrsc=T))))<4)
}
}
z.pca = pca.hy(normData,subt.mean=F)
pc.j = which(apply(z.pca$projmat[1:5,],1,maincomp)==1)
if (length(pc.j)>0) {
rprojmat = apply(matrix(z.pca$dirmat[,pc.j],ncol=length(pc.j)),2,
FUN=function(t){get_rps(X=normData,dir=t)})
normData2 = normData - z.pca$dirmat[,pc.j]%*%t(rprojmat)
} else {
normData2 = normData
}
correct_PO = function(x,ADcutoff=4) {
require(diptest)
AD = ADstatWins.hy(x,trim=0.1)
if (dip.test(x)$p.value<0.005) {
ADcutoff = 10
}
if (AD > ADcutoff) {
X = matrix(0,ncol=length(x),nrow=100)
X = t(sapply(1:100,FUN=function(t){transform_normalike(x,ADcutoff=ADcutoff)}))
# for (k in 1:50) {
#   X[k,] = make_normal(x)
# }
return(apply(X,2,mean))
} else {
return(pd.rate.hy(x,qrsc=F))
}
}
pc.j = which(apply(z.pca$projmat[1:5,],1,maincomp)==1)
source('~/Dropbox/Research/Hayes-lab/HNSC_local/method_test/test.R', echo=TRUE)
source('~/Dropbox/Research/Hayes-lab/HNSC_local/method_test/test.R', echo=TRUE)
pc.j = which(apply(z.pca$projmat[1:5,],1,maincomp)==1)
if (length(pc.j)>0) {
rprojmat = apply(matrix(z.pca$dirmat[,pc.j],ncol=length(pc.j)),2,
FUN=function(t){get_rps(X=normData,dir=t)})
normData2 = normData - z.pca$dirmat[,pc.j]%*%t(rprojmat)
} else {
normData2 = normData
}
warnings()
set.seed(0)
siglev=siglev
ADcutoff=4
inputData=normData2
pileupData=pileupData
Ranges=Ranges
JSR.table=JSR.table
print.proc=F
AToutlier=T
n = dim(inputData)[2]
plat.table = build_blockTable(Ranges=Ranges)
plat.baseMat = build_baseMat(plat.table)
size.adjMat = sqrt(t(plat.baseMat)%*%plat.baseMat)
exonlabels = label_exons(pileupData=pileupData,Ranges=Ranges)
estexons = names(which(exonlabels==1))
exonlabels
knownDir = build_knownDir(plat.table=plat.table,Ranges=Ranges,JSR.table=JSR.table,exons=estexons)
adj.knownDir = size.adjMat%*%knownDir # adjust size of plats
plat.names = rownames(knownDir)
plat.names2 = sapply(plat.names,FUN=function(t){unlist(strsplit(t,"[.]"))[1]})
platBasisDir = apply(plat.baseMat,2,get_unitdir)
KnownBasisDir = apply(plat.baseMat%*%knownDir,2,get_unitdir)
normProjData = t(platBasisDir) %*% inputData # low-dimensional data object to be used for outlier detection
## 1. Detecting outliers from known directions
## 1-1. Get projection outlyingness
# Get primary projection outlyingness
knownPOmat = get_POgivenB2(X=normProjData,B=adj.knownDir,qrsc=TRUE,ADcutoff=ADcutoff)
knownPO = diag(knownPOmat[apply(abs(knownPOmat),2,which.max),])
knownPO
## 1-2. Detecting non-outliers
intron.nonout = get_intron_nonout(pileupData=pileupData,Range=Ranges)
rm(pileup)
rm(pileupData)
rm(normData)
rm(normData2)
GeneName="TP53"
logshiftVal = 10
siglev = 1e-4
regions = GenesExons[which(GenesExons[,1]==GeneName),2]
if (GeneName=="TP53") {
regions = "chr17:7571720-7573008,7573927-7574033,7576525-7576657,7576853-7576926,7577019-7577155,7577499-7577608,7578177-7578289,7578371-7578554,7579312-7579590,7579700-7579721,7579839-7579940:-"
}
Ranges = get_Ranges(Gene=GeneName,regions=regions,outputType="part_intron")
load(file=paste0(data.dir,GeneName,"_pileup.RData"))
JSR.count = read.table(file=paste0(data.dir,GeneName,"_SRcount.txt"),header=T)
# source(paste0(SCISSORdir,"R/get_junctions.R"))
jsrCount = data.matrix(JSR.count[,2])
rownames(jsrCount) = JSR.count[,1]
# head(jsrCount)
junction.anno = get_junctions(jsrCount=jsrCount,Ranges=Ranges)
JSR.table = junction.anno$JSR.annotation
JSR.matrix = junction.anno$JSRmat
## Mutations
mutation.info = myGeneS.info[[which(genome.list==GeneName)]]
impt.mutations=c("Splice_Site","Nonsense_Mutation","In_Frame_Ins",
"Frame_Shift_Del","In_Frame_Del","Frame_Shift_Ins",
"Silent")
group_mut = as.list(NULL);
group_mut[[1]] = which(mut_types=="Splice_Site")
group_mut[[2]] = which(mut_types=="Nonsense_Mutation") # nonsense
group_mut[[3]] = c(which(mut_types=="In_Frame_Ins"),which(mut_types=="Frame_Shift_Del"),
which(mut_types=="In_Frame_Del"),which(mut_types=="Frame_Shift_Ins")) # frame shift
group_mut[[4]] = which(mut_types=="Silent") # silent
group_mut[[5]] = which(!mut_types %in% impt.mutations)  # the rest
group_mut_types = c("Splice_site","Nonsense","Frame_shift","Silent","Other")
start.time=Sys.time()
set.seed(0)
if (exists(x="ScissorOutput")) rm(ScissorOutput)
ScissorOutput=Scissor(pileupData=pileupData,Ranges=Ranges,
siglev=siglev,logshiftVal=logshiftVal,windowSize=50,
plotNormalization=FALSE,reducedReturn=FALSE)
end.time=Sys.time()
end.time-start.time
data.process = process_pileup(pileupData=pileupData,Ranges=Ranges,
logshiftVal=logshiftVal,
plotNormalization=F)
if (exists(x="normData")) rm(normData)
if (exists(x="logData")) rm(logData)
normData = data.process$normalizedData
logData = data.process$logData
logshiftVal = data.process$logshiftVal  # log shift parameter
cat(paste0("     Log shift parameter used  = ",logshiftVal),"\n")
get_rps = function(X,dir) {
# robust projection scores by projecting X onto dir.
require(MASS)
return(apply(X,2,FUN=function(t){rlm(t ~ dir - 1, psi=psi.bisquare)$coefficients}))
}
maincomp = function(x) {
# 1 = main / 0 = outlier
require(diptest)
if (dip.test(x)$p.value<0.005) {
(max(abs(correct_PO(pd.rate.hy(x,qrsc=T))))<3)
} else {
(max(abs(correct_PO(pd.rate.hy(x,qrsc=T))))<4)
}
}
z.pca = pca.hy(normData,subt.mean=F)
pc.j = which(apply(z.pca$projmat[1:5,],1,maincomp)==1)
if (length(pc.j)>0) {
rprojmat = apply(matrix(z.pca$dirmat[,pc.j],ncol=length(pc.j)),2,
FUN=function(t){get_rps(X=normData,dir=t)})
normData2 = normData - z.pca$dirmat[,pc.j]%*%t(rprojmat)
} else {
normData2 = normData
}
start.time=Sys.time()
set.seed(0)
globalResult = miscGlobal_test5(siglev=siglev,ADcutoff=4,
inputData=normData2,pileupData=pileupData,
Ranges=Ranges,JSR.table=JSR.table,print.proc=F)
localResult = miscLocal_test2(siglev=siglev,windowSize=50,
miscGlobalResult=globalResult,
inputData=normData2,pileupData=pileupData,
Ranges=Ranges,JSR.table=JSR.table)
end.time=Sys.time()
end.time-start.time
globalResult$table
localResult$table
dim(pileupData)
getwd()
?build_gaf
getwd()
getwd()
getwd()
library("devtools"); library("roxygen2");
document()
library(devtools)
devtools::decument()
devtools::document()
devtools::install()
library(SCISSOR)
len.intron.hy
build_pileup
library(roxygen2)
document()
library(devtools)
decument()
document()
build()
check()
library(devtools)
document()
check()
document()
document()
library(ballgown)
