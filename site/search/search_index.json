{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"SCISSOR SCISSOR is an R package containing tools for statistical analysis and visualization of base-level RNA-seq data. Overview SCISSOR (shape changes in selecting sample outliers in RNA-seq) aims for unsupervised screening of a range of structural alterations in RNA-seq data. SCISSOR considers a novel shape property of aligned short read data through a base-level pileup file. This intact and uncompressed view of RNA-seq profile enables the unbiased discovery of structural alterations by looking for anomalous shapes in expression. This approach holds promise for identifying otherwise obscured genetic aberrations. As a result, SCISSOR identifies known as well as novel aberrations including abnormal splicing, intra-/intergenic deletions, small indels, alternative transcription start/termination. Statistical model With the goal of detecting samples exhibiting anomalous shapes, SCISSOR models base-level read counts using a high-dimensional latent variable framework that is naturally integrated to its normalization, abnormal feature extraction, and quantification. A latent variable is used to model an underlying abnormal trajectory, i.e. an outlier direction in a high-dimensional space, that is interrogated for outliers. An outlier case with shape changes then can be a data point that is strongly involved in one or multiple abnormal trajectories, which enables modeling complex structural variation. Statistical method SCISSOR extracts a latent space associated with abnormal sequencing coverage and quantifies the level of abnormality in a robust way for determining the cases with shape changes. As the type of structure of interest is outlying/abnormal, it uses a projection pursuit approach to measure how outlying a sample is in the most extreme one-dimensional direction. At each gene under consideration, the resulting statistic is an outlyingness score for each sample with larger values indicating more severe deviation from other samples in the dataset. For each outlier, SCISSOR produces the most outlying direction as a single best trajectory that describes abnormalities of the corresponding outlier, which can be used to recover the latent space of outlying outlier directions. Free software SCISSOR is free software and available on Github . Documentation Getting Started Tutorial Demo","title":"SCISSOR"},{"location":"#scissor","text":"SCISSOR is an R package containing tools for statistical analysis and visualization of base-level RNA-seq data.","title":"SCISSOR"},{"location":"#overview","text":"SCISSOR (shape changes in selecting sample outliers in RNA-seq) aims for unsupervised screening of a range of structural alterations in RNA-seq data. SCISSOR considers a novel shape property of aligned short read data through a base-level pileup file. This intact and uncompressed view of RNA-seq profile enables the unbiased discovery of structural alterations by looking for anomalous shapes in expression. This approach holds promise for identifying otherwise obscured genetic aberrations. As a result, SCISSOR identifies known as well as novel aberrations including abnormal splicing, intra-/intergenic deletions, small indels, alternative transcription start/termination.","title":"Overview"},{"location":"#statistical-model","text":"With the goal of detecting samples exhibiting anomalous shapes, SCISSOR models base-level read counts using a high-dimensional latent variable framework that is naturally integrated to its normalization, abnormal feature extraction, and quantification. A latent variable is used to model an underlying abnormal trajectory, i.e. an outlier direction in a high-dimensional space, that is interrogated for outliers. An outlier case with shape changes then can be a data point that is strongly involved in one or multiple abnormal trajectories, which enables modeling complex structural variation.","title":"Statistical model"},{"location":"#statistical-method","text":"SCISSOR extracts a latent space associated with abnormal sequencing coverage and quantifies the level of abnormality in a robust way for determining the cases with shape changes. As the type of structure of interest is outlying/abnormal, it uses a projection pursuit approach to measure how outlying a sample is in the most extreme one-dimensional direction. At each gene under consideration, the resulting statistic is an outlyingness score for each sample with larger values indicating more severe deviation from other samples in the dataset. For each outlier, SCISSOR produces the most outlying direction as a single best trajectory that describes abnormalities of the corresponding outlier, which can be used to recover the latent space of outlying outlier directions.","title":"Statistical method"},{"location":"#free-software","text":"SCISSOR is free software and available on Github .","title":"Free software"},{"location":"#documentation","text":"Getting Started Tutorial Demo","title":"Documentation"},{"location":"about/","text":"Morte novissima famulos potest parientem vino sui Egredere recolligis Lorem markdownum gerunt, sit Agenorides consolor pauca, plangore canem contentis obductos. Hoc est inter sed sceleri unde sive Quae de oscula sacras daulida. Tacti tauri atque, si rigido et pars aut adiutrixque si deam colligit se vastum ille sedem inpatiensque auditi! Vulnere habet tuto deus aris Erectheas sorores laedor humi erat tamquam plectro habebat unaque et. Adiit pedibus Aether cum nomina subitis invidet cingitur species Aristis ego trahit Lacertos et habenas sedebat fallere Mille tangor et ipsa etiamnum isdem tremula. Qui in quoque laboras deus, cessit illa illo rostris exhibuit tradiderat generoso citharae curis? Matrona onus donis nefas parva cavus, vellet in placidi nigrae minatur. Futura et medias clipeum . Cursus repugnat Icare, cum! Vel virum iamdudum herbae Urnam quod ponunt supremo Phoebe, res vectus lugebat, inposuit navita quamquam? Aberant forma, fuit merui herba novit promisitque erigor Agenoream, unam sparsum et quae annis quantumque. torrentIspMountain += nameData; compatible(retina_ocr_piracy, -2); disk_heap_drive += led_ring; Necem ducitur sentire Cum Limnaee . Et carpe signo luctibus mutatus coniuge , attritas non, mille nisi ambieratque duorum; quam. Eripere ne imbres imagine facto. Equi ubi etiam meo hamatis terra illum tenentibus vidit vertuntur, dei et nec inter. Sine quaque sacrata oculis distulit quidem quis aquas facti qui vincis valle gutture unam spinae di. Eras more vates temeraria perarantem cruore igitur Ope dixit his taeda persequerer possis haberet his, quo toto illa. Caelum esse, ad longa habentia ? Aetatis sequendo. Illa subit: marem dedit. Est virgo habitus: dapes nec; tristis sua quae rerum sospite Amphitryoniaden medioque? Ne malum quisquis reconditus illi; sic huc caelumque ferebat , Iovis. Parvum si toto iacit Romane; Mopsopium referuntur processisse tempore poena : peperit potes murra mater quaque deduxit, ait? Enim palluit inemptum, abdita Tyndaridae ne felices te celer.","title":"Morte novissima famulos potest parientem vino sui"},{"location":"about/#morte-novissima-famulos-potest-parientem-vino-sui","text":"","title":"Morte novissima famulos potest parientem vino sui"},{"location":"about/#egredere-recolligis","text":"Lorem markdownum gerunt, sit Agenorides consolor pauca, plangore canem contentis obductos. Hoc est inter sed sceleri unde sive Quae de oscula sacras daulida. Tacti tauri atque, si rigido et pars aut adiutrixque si deam colligit se vastum ille sedem inpatiensque auditi! Vulnere habet tuto deus aris Erectheas sorores laedor humi erat tamquam plectro habebat unaque et. Adiit pedibus Aether cum nomina subitis invidet cingitur species Aristis ego trahit","title":"Egredere recolligis"},{"location":"about/#lacertos-et-habenas-sedebat-fallere","text":"Mille tangor et ipsa etiamnum isdem tremula. Qui in quoque laboras deus, cessit illa illo rostris exhibuit tradiderat generoso citharae curis? Matrona onus donis nefas parva cavus, vellet in placidi nigrae minatur. Futura et medias clipeum . Cursus repugnat Icare, cum!","title":"Lacertos et habenas sedebat fallere"},{"location":"about/#vel-virum-iamdudum-herbae","text":"Urnam quod ponunt supremo Phoebe, res vectus lugebat, inposuit navita quamquam? Aberant forma, fuit merui herba novit promisitque erigor Agenoream, unam sparsum et quae annis quantumque. torrentIspMountain += nameData; compatible(retina_ocr_piracy, -2); disk_heap_drive += led_ring;","title":"Vel virum iamdudum herbae"},{"location":"about/#necem-ducitur-sentire","text":"Cum Limnaee . Et carpe signo luctibus mutatus coniuge , attritas non, mille nisi ambieratque duorum; quam. Eripere ne imbres imagine facto. Equi ubi etiam meo hamatis terra illum tenentibus vidit vertuntur, dei et nec inter. Sine quaque sacrata oculis distulit quidem quis aquas facti qui vincis valle gutture unam spinae di.","title":"Necem ducitur sentire"},{"location":"about/#eras-more-vates-temeraria-perarantem-cruore-igitur","text":"Ope dixit his taeda persequerer possis haberet his, quo toto illa. Caelum esse, ad longa habentia ? Aetatis sequendo. Illa subit: marem dedit. Est virgo habitus: dapes nec; tristis sua quae rerum sospite Amphitryoniaden medioque? Ne malum quisquis reconditus illi; sic huc caelumque ferebat , Iovis. Parvum si toto iacit Romane; Mopsopium referuntur processisse tempore poena : peperit potes murra mater quaque deduxit, ait? Enim palluit inemptum, abdita Tyndaridae ne felices te celer.","title":"Eras more vates temeraria perarantem cruore igitur"},{"location":"example/","text":"A toy dataset is available in the SCISSOR package: library(SCISSOR) data(TOY_data) This dataset contains base-level coverage of a hypothetical gene TOY including three exons and the whole intronic regions between the exons. Among n=260 cases, there are eight samples with strong shape changes. Here, we aim to identify these eight shape changes using SCISSOR . Data preparation We first obtain pileup data matrix using build_pileup and genomic ranges using get_Ranges that will be used as inputs for the function Scissor : Gene = toygene_symbol regions = toygene_regions pileupData = build_pileup(Pileup=toygene_coverage,regions=regions, inputType=\"whole_intron\",outputType=\"part_intron\") geneRanges = get_Ranges(Gene=\"TOY\",regions=regions,outputType=\"part_intron\") caseIDs = colnames(pileupData) In practice, you will often obtain pileup data directly from BAM files. This can be done with read_BAM (see Tutorial ). If you do not specify sample IDs, the build_pileup and read_BAM will generate the IDs by default as follows: > head(caseIDs) [1] \"case-1\" \"case-2\" \"case-3\" \"case-4\" \"case-5\" \"case-6\" Statistical analysis The whole procedures of SCISSOR can be performed by using all-in-one function Scissor (see Tutorial ). ScissorOutput=Scissor(pileupData=pileupData,Ranges=geneRanges) The object ScissorOutput is a large list containing the results. The identified shape changes are saved in ScissorOutput$SC and the resulting outlyingness scores from each of the global and local procedures are saved in ScissorOutput$GSC$OS and ScissorOutput$LSC$OS , respectively. You can plot the outlyingness scores using plot_ScissorOS : par(mfrow=c(1,2)) plot_ScissorOS(object=ScissorOutput,colmat=NULL,textSC=TRUE) The figures show the indices of outlier samples with the kernel desntify estimates from the scores. You can also visualize the identified shape changes using plot_pileup : par(mfrow=c(4,2),mar=c(2,2,2,2)) for (case in ScissorOutput$SC) { plot_pileup(Pileup=ScissorOutput$logData,Ranges=geneRanges,cases=case, logcount=ScissorOutput$logshiftVal) } The first seven outliers are associated with exon skipping or intron retention whereas the last outlier is showing small deletion in the middle of the first exon.","title":"Demo"},{"location":"example/#data-preparation","text":"We first obtain pileup data matrix using build_pileup and genomic ranges using get_Ranges that will be used as inputs for the function Scissor : Gene = toygene_symbol regions = toygene_regions pileupData = build_pileup(Pileup=toygene_coverage,regions=regions, inputType=\"whole_intron\",outputType=\"part_intron\") geneRanges = get_Ranges(Gene=\"TOY\",regions=regions,outputType=\"part_intron\") caseIDs = colnames(pileupData) In practice, you will often obtain pileup data directly from BAM files. This can be done with read_BAM (see Tutorial ). If you do not specify sample IDs, the build_pileup and read_BAM will generate the IDs by default as follows: > head(caseIDs) [1] \"case-1\" \"case-2\" \"case-3\" \"case-4\" \"case-5\" \"case-6\"","title":"Data preparation"},{"location":"example/#statistical-analysis","text":"The whole procedures of SCISSOR can be performed by using all-in-one function Scissor (see Tutorial ). ScissorOutput=Scissor(pileupData=pileupData,Ranges=geneRanges) The object ScissorOutput is a large list containing the results. The identified shape changes are saved in ScissorOutput$SC and the resulting outlyingness scores from each of the global and local procedures are saved in ScissorOutput$GSC$OS and ScissorOutput$LSC$OS , respectively. You can plot the outlyingness scores using plot_ScissorOS : par(mfrow=c(1,2)) plot_ScissorOS(object=ScissorOutput,colmat=NULL,textSC=TRUE) The figures show the indices of outlier samples with the kernel desntify estimates from the scores. You can also visualize the identified shape changes using plot_pileup : par(mfrow=c(4,2),mar=c(2,2,2,2)) for (case in ScissorOutput$SC) { plot_pileup(Pileup=ScissorOutput$logData,Ranges=geneRanges,cases=case, logcount=ScissorOutput$logshiftVal) } The first seven outliers are associated with exon skipping or intron retention whereas the last outlier is showing small deletion in the middle of the first exon.","title":"Statistical analysis"},{"location":"installation/","text":"Install from Github First, install devtools : if (\"devtools\" %in% rownames(installed.packages()) == FALSE) {install.packages(\"devtools\")} library(devtools) Next, install SCISSOR : install_github(\"hyochoi/SCISSOR\") library(SCISSOR) R package dependencies SCISSOR requires the following packages: BiocManager Rsamtools GenomicRanges refGenome RColorBrewer wesanderson nloptr zoo","title":"Getting Started"},{"location":"installation/#install-from-github","text":"First, install devtools : if (\"devtools\" %in% rownames(installed.packages()) == FALSE) {install.packages(\"devtools\")} library(devtools) Next, install SCISSOR : install_github(\"hyochoi/SCISSOR\") library(SCISSOR)","title":"Install from Github"},{"location":"installation/#r-package-dependencies","text":"SCISSOR requires the following packages: BiocManager Rsamtools GenomicRanges refGenome RColorBrewer wesanderson nloptr zoo","title":"R package dependencies"},{"location":"tutorial/","text":"Tutorial This tutorial is for a single gene analysis with SCISSOR . For more information, you can find R documentation for each function using ?function . E.g.: ?read_BAM Get gene annotation SCISSOR needs gene annotation (genomic ranges for exons) formatted as \"chr1:1-100,200-300:+\". You can use build_gaf to obtain gene annotation from GTF file. Make sure that you specify a gene symbol, e.g. TP53, as an input in build_gaf . Gene = \"TP53\" regions = build_gaf(Gene=Gene,GTF.file=\"./Homo_sapiens.GRCh37.87.gtf\") Suppose that GTF file have information about our hypothetical gene, \"TOY\". (See Demo ) Then, the build_gaf gives the exons for the gene \"TOY\", and the output will be something like: > regions [1] \"chrQ:7571719-7572198,7574858-7575157,7598088-7598437:-\" Get coverage from BAM files SCISSOR takes base-level pileup for a single gene as an input. If you want to get the pileup data from BAM files, you can use read_BAM . Suppose that your BAM files are located under the directory, ~/bamDir/. You can read the part of the BAM files for particular regions of interest into R. Then, the resulting data object pileupData is a matrix where samples are in columns and genomic coordinates are in rows. If you have IDs for your samples, you can specify them for the argument caseIDs with the same order as the BAMfiles . BAMfiles = list.files(path=\"~/bamDir/\") BAMfilesPath = as.character(sapply(BAMfiles,function(x) paste(getwd(),x,sep=\"/\"))) pileupData = read_BAM(BAMfiles=bamfilesPath,caseIDs=case.barcodes, symbol=Gene,regions=regions,outputType=outputType) outputType is to set the type of intronic region that will be included in the pileup output, with choices \"whole_intron\", \"part_intron\" (default), or \"only_exon\". If you want SCISSOR to look for changes in intronic regions, it is good to set outputType =\"part_intron\". Gene models are modified to include a portion but not all of intronic regions to facilitate the common alterations that involve intron-exon boundaries. The omission of large portions of introns is reasonable because they complicate the visualization of RNA pileups and add little to biologic signal. To determine which parts of introns to be included in the model, a basic rule is that the total lengths of bases for all exons and all introns at a gene to be approximately equal for the current SCISSOR application. This helps to make variations of expression at exonic regions and intronic regions comparable. More details on the rule for determining the intronic regions are in Methods of the paper (cite). outputType =\"only_exon\" may be useful when you are only interested in changes in exons (e.g. exon skipping, alternative exon, deletion, etc.). We do not recommend outputType =\"whole_intron\" for the statistical analysis of SCISSOR because it is very likely to add a large amount of noise rather than signals. However, outputType =\"whole_intron\" can be useful when you want to visualize coverage with whole intronic regions. Get genomic ranges for SCISSOR analysis An important step of SCISSOR is to get genomic ranges for the gene of interest using get_Ranges . Wait, we already obtained regions previously... Why do we need this step? This step is needed to specify what regions are included in the analysis because our data object (pileup) might include part of the introns, whole exons, or only exons, which can be different from regions . Determined by the argument outputType , we get our new annotation to be used in the downstream analysis. geneRanges = get_Ranges(Gene=Gene,regions=regions,outputType=\"part_intron\") Using this new annotation geneRanges as an input in other core functions, we let them know our genomic ranges of interest. Plot coverage Let's plot coverage using plot_pileup for the TOY gene. Here, we randomly chose a subset of samples (randomSamples). plot_pileup(Pileup=pileupData,Ranges=geneRanges,cases=randomSamples, main=\"Raw coverage\") Let's plot the log-transformed coverage ($ \\log (pileup + c) $) where $c$ is a pseudo count that is added before the log-transformation. To print labels for raw read count instead of log-transformed read count on the y-axis, you can specify the pseudo-count ($c$) for the argument logcount . plot_pileup(Pileup=log10(pileupData+1),Ranges=geneRanges,cases=randomSamples, main=\"Log-transformed coverage\",logcount=1) Run SCISSOR Scissor is all-in-one function performing transformation, normalization, and the statistical analysis. We have base-level pileup data (as the object, pileupData ) and genomic ranges (as the object, geneRanges ) from the previous steps. Scissor takes these as inputs with other options to identify various types of structural changes such as abnormal splicing (exon skipping and intron retention), alternative transcription start or termination, small deletions, and etc. You can use Scissor as the following simple command: ScissorOutput=Scissor(pileupData=pileupData,Ranges=geneRanges) Scissor performs: logarithmic transformation by automatically choosing the log shift parameter base-level normalization global shape change detection by exploring all possible low-dimensional space local shape change detection by exploring residual space Scissor provides: shape changes identified outlyingness scores (global and local) cutoff values (global and local) most outlyingness directions for the identified shape changes For more information, see the R documentaion: ?Scissor or help(Scissor) .","title":"Tutorial"},{"location":"tutorial/#tutorial","text":"This tutorial is for a single gene analysis with SCISSOR . For more information, you can find R documentation for each function using ?function . E.g.: ?read_BAM","title":"Tutorial"},{"location":"tutorial/#get-gene-annotation","text":"SCISSOR needs gene annotation (genomic ranges for exons) formatted as \"chr1:1-100,200-300:+\". You can use build_gaf to obtain gene annotation from GTF file. Make sure that you specify a gene symbol, e.g. TP53, as an input in build_gaf . Gene = \"TP53\" regions = build_gaf(Gene=Gene,GTF.file=\"./Homo_sapiens.GRCh37.87.gtf\") Suppose that GTF file have information about our hypothetical gene, \"TOY\". (See Demo ) Then, the build_gaf gives the exons for the gene \"TOY\", and the output will be something like: > regions [1] \"chrQ:7571719-7572198,7574858-7575157,7598088-7598437:-\"","title":"Get gene annotation"},{"location":"tutorial/#get-coverage-from-bam-files","text":"SCISSOR takes base-level pileup for a single gene as an input. If you want to get the pileup data from BAM files, you can use read_BAM . Suppose that your BAM files are located under the directory, ~/bamDir/. You can read the part of the BAM files for particular regions of interest into R. Then, the resulting data object pileupData is a matrix where samples are in columns and genomic coordinates are in rows. If you have IDs for your samples, you can specify them for the argument caseIDs with the same order as the BAMfiles . BAMfiles = list.files(path=\"~/bamDir/\") BAMfilesPath = as.character(sapply(BAMfiles,function(x) paste(getwd(),x,sep=\"/\"))) pileupData = read_BAM(BAMfiles=bamfilesPath,caseIDs=case.barcodes, symbol=Gene,regions=regions,outputType=outputType) outputType is to set the type of intronic region that will be included in the pileup output, with choices \"whole_intron\", \"part_intron\" (default), or \"only_exon\". If you want SCISSOR to look for changes in intronic regions, it is good to set outputType =\"part_intron\". Gene models are modified to include a portion but not all of intronic regions to facilitate the common alterations that involve intron-exon boundaries. The omission of large portions of introns is reasonable because they complicate the visualization of RNA pileups and add little to biologic signal. To determine which parts of introns to be included in the model, a basic rule is that the total lengths of bases for all exons and all introns at a gene to be approximately equal for the current SCISSOR application. This helps to make variations of expression at exonic regions and intronic regions comparable. More details on the rule for determining the intronic regions are in Methods of the paper (cite). outputType =\"only_exon\" may be useful when you are only interested in changes in exons (e.g. exon skipping, alternative exon, deletion, etc.). We do not recommend outputType =\"whole_intron\" for the statistical analysis of SCISSOR because it is very likely to add a large amount of noise rather than signals. However, outputType =\"whole_intron\" can be useful when you want to visualize coverage with whole intronic regions.","title":"Get coverage from BAM files"},{"location":"tutorial/#get-genomic-ranges-for-scissor-analysis","text":"An important step of SCISSOR is to get genomic ranges for the gene of interest using get_Ranges . Wait, we already obtained regions previously... Why do we need this step? This step is needed to specify what regions are included in the analysis because our data object (pileup) might include part of the introns, whole exons, or only exons, which can be different from regions . Determined by the argument outputType , we get our new annotation to be used in the downstream analysis. geneRanges = get_Ranges(Gene=Gene,regions=regions,outputType=\"part_intron\") Using this new annotation geneRanges as an input in other core functions, we let them know our genomic ranges of interest.","title":"Get genomic ranges for SCISSOR analysis"},{"location":"tutorial/#plot-coverage","text":"Let's plot coverage using plot_pileup for the TOY gene. Here, we randomly chose a subset of samples (randomSamples). plot_pileup(Pileup=pileupData,Ranges=geneRanges,cases=randomSamples, main=\"Raw coverage\") Let's plot the log-transformed coverage ($ \\log (pileup + c) $) where $c$ is a pseudo count that is added before the log-transformation. To print labels for raw read count instead of log-transformed read count on the y-axis, you can specify the pseudo-count ($c$) for the argument logcount . plot_pileup(Pileup=log10(pileupData+1),Ranges=geneRanges,cases=randomSamples, main=\"Log-transformed coverage\",logcount=1)","title":"Plot coverage"},{"location":"tutorial/#run-scissor","text":"Scissor is all-in-one function performing transformation, normalization, and the statistical analysis. We have base-level pileup data (as the object, pileupData ) and genomic ranges (as the object, geneRanges ) from the previous steps. Scissor takes these as inputs with other options to identify various types of structural changes such as abnormal splicing (exon skipping and intron retention), alternative transcription start or termination, small deletions, and etc. You can use Scissor as the following simple command: ScissorOutput=Scissor(pileupData=pileupData,Ranges=geneRanges) Scissor performs: logarithmic transformation by automatically choosing the log shift parameter base-level normalization global shape change detection by exploring all possible low-dimensional space local shape change detection by exploring residual space Scissor provides: shape changes identified outlyingness scores (global and local) cutoff values (global and local) most outlyingness directions for the identified shape changes For more information, see the R documentaion: ?Scissor or help(Scissor) .","title":"Run SCISSOR"}]}